<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.random API documentation</title>
<meta name="description" content="Sample from efficient distributions …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.random</code></h1>
</header>
<section id="section-intro">
<p>Sample from efficient distributions.</p>
<p>The difference between these classes and the classes in <code>pylab.variables</code> is that
these are just efficnet wrappers of functions that do not require instantiating a
node whereas the classes in <code>pylab.variables</code> are meant to be inherited for posteriors
and to instantiate as objects. The functions of the distributions in <code>pylab.variables</code>
are implemented here</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Sample from efficient distributions.

The difference between these classes and the classes in `pylab.variables` is that
these are just efficnet wrappers of functions that do not require instantiating a
node whereas the classes in `pylab.variables` are meant to be inherited for posteriors
and to instantiate as objects. The functions of the distributions in `pylab.variables`
are implemented here
&#39;&#39;&#39;

import numpy as np
import math
import numpy.random as npr
import pickle
import random
import logging
import warnings
import sys
import scipy.stats

# Typing
from typing import TypeVar, Generic, Any, Union, Dict, Iterator, Tuple, Callable, List

from .base import Saveable
from .errors import MathError, UndefinedError
try:
    import _sample as c_sample
    # warnings.warn(&#39;PYLAB - USING C VERSIONS FOR DISTRIBUTIONS&#39;)

    C_SAMPLE = c_sample.Sample()
    CUSTOM_DIST_AVAIL = True
except ImportError as e:
    print(e)
    warnings.warn(&#39;PYLAB - WAS NOT ABLE TO IMPORT C VERSIONS OF DISTRIBUTIONS.&#39; \
        &#39; USING DEFAULT PYTHON INSTEAD.&#39;)
    CUSTOM_DIST_AVAIL = False


# For caluclating pdf, logpdf, cdf, logcdf - faster access and precomputation
import numba # for compiling and forcing function to stay in cache
from math import sqrt as SQRT
from math import pi as _PI
from math import erf as ERF
from math import gamma as GAMMA
from math import lgamma as LGAMMA
from numpy import exp as EXP
from numpy import log as LOG
from numpy import square as SQD

_INV_SQRT_2PI = 1/SQRT(2*_PI)
_LOG_INV_SQRT_2PI = LOG(1/SQRT(2*_PI))
_LOG_2PI = LOG(2*_PI)
_INV_SQRT_2 = 1/SQRT(2)
_LOG_INV_SQRT_2 = LOG(1/SQRT(2))
_LOG_ONE_HALF = LOG(0.5)
_NEGINF = float(&#39;-inf&#39;)

def israndom(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of BaseRandom (not a
    random variable (isRandomVariable))

    Parameters
    ----------
    x : any
        Input instance to check the type of BaseRandom

    Returns
    -------
    bool
        True if `x` is of type BaseRandom, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, _BaseSample)

def seed(x: int):
    &#39;&#39;&#39;Sets all of the seeds with the given seed `x`

    Parameters
    ----------
    x (int)
        Seed to set everything at
    &#39;&#39;&#39;
    np.random.seed(x)
    random.seed(x)
    if CUSTOM_DIST_AVAIL:
        C_SAMPLE.seed(x)

def _safe_cholesky(M: np.ndarray, jitter: bool=False, save_if_crash: bool=False):
    # if scipy.sparse.issparse(M):
    #     M = M.toarray()

    try:
        # if type(M) == torch.Tensor:
        #     L = torch.cholesky(M)
        # else:
        return np.linalg.cholesky(M)
    except:
        try:
            return scipy.linalg.cholesky(M)
        except:
            if not jitter:
                if save_if_crash:
                    saveloc = &#39;this_is_what_made_cholesky_crash_{}.npy&#39;.format(os.getpid())
                    np.save(saveloc, M)
                raise
        jitter = 1e-9
        while jitter &lt; 1.0:
            try:
                L = np.linalg.cholesky(M + np.diag(jitter*np.ones(M.shape[0])))
                logging.warning(&#39;jitter threshold: {}&#39;.format(jitter))
                return L
            except:
                jitter *= 10

    if save_if_crash:
        saveloc = &#39;this_is_what_made_cholesky_crash_{}.npy&#39;.format(os.getpid())
        np.save(saveloc, M)
    raise MathError(&#39;Cholesky could not be calculated with jitter. Array that &#39; \
        &#39;crashed the system saved as `this_is_what_made_cholesky_crash.npy`&#39;)

def _log_det_func(M: np.ndarray) -&gt; float:
    # if scipy.sparse.issparse(M):
    #     M_ = M.toarray()
    # else:
    #     M_ = M
    L = _safe_cholesky(M)
    return 2*np.sum(np.log(np.diag(L)))

class misc:
    &#39;&#39;&#39;These are miscellaneus methods
    &#39;&#39;&#39;
    @staticmethod
    def multivariate_normal_fast_2d(mean: Union[np.ndarray, List], 
        cov: np.ndarray) -&gt; Union[np.ndarray, List]:
        &#39;&#39;&#39;Sample from 2d normal.

        Parameters
        ----------
        mean : 1d array
        cov : 2 x 2 array

        Returns
        -------
        np.ndarray (2,)
            Two samples
        &#39;&#39;&#39;
        z0 = C_SAMPLE.c_standard_normal()
        SQRT_COV_00 = math.sqrt(cov[0,0])
        mean[0] += SQRT_COV_00 * z0
        mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
            cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
        return mean

    @staticmethod
    def fast_sample_standard_uniform() -&gt; float:
        &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
        &#39;&#39;&#39;
        return C_SAMPLE.c_standard_uniform()

    @staticmethod
    def fast_sample_normal(loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
        Only accepts floats

        Parameters
        ----------
        loc, scale : float
            Mean and standard devition, respectively

        Returns
        -------
        float
        &#39;&#39;&#39;
        return C_SAMPLE.c_normal(loc, scale)


class _BaseSample:

    @staticmethod
    def sample(*args, **kwargs):
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def pdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the pdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def logpdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the logpdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def cdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the cdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def logcdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the logcdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)


class normal(_BaseSample):
    &#39;&#39;&#39;Normal distribution parameterized by a mean and standard deviation
    &#39;&#39;&#39;
    @staticmethod
    def sample(loc: Union[float, np.ndarray]=0, scale: Union[float, np.ndarray]=1,
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a normal random distribution. This can be vectorized

        NOTE: If you want to sample a single scalar value with a normal distribution,
        use the function `mdsine2.random.misc.fast_sample_normal`

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float

        See Also
        --------
        mdsine2.random.misc.fast_sample_normal
        &#39;&#39;&#39;
        return npr.normal(loc, scale, size=size)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _INV_SQRT_2PI * EXP(-0.5*((value-loc)/scale)**2) / scale

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_INV_SQRT_2PI + (-0.5*((value-loc)/scale)**2) - LOG(scale)


    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def cdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the cumulative density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logcdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log cumulative density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))


class lognormal(_BaseSample):
    &#39;&#39;&#39;Log-normal distribution:
    X = exp(\mu + \sigma Z), Z ~ Normal(0,1)
    &#39;&#39;&#39; 
    @staticmethod
    def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a log-normal random distribution. This can be vectorized

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return np.exp(loc + scale * npr.normal(0,1,size=size))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a log-normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _INV_SQRT_2PI * (1/(scale*value)) * EXP(-0.5 * \
            ((LOG(value)-loc)/scale) ** 2)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a log-normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_INV_SQRT_2PI - LOG(scale) - LOG(value) + \
            (-0.5*((LOG(value)-loc)/scale)**2)


class truncnormal(_BaseSample):
    &#39;&#39;&#39;Truncated normal distribution.

    We parameterize the truncated normal distribution with the mean `loc` and 
    standard deviation `scale` of the underlying normal distirbution and then we
    specified the truncation bounds:    
    
    For example:
        mdsine2.random.truncnormal.sample(0, 3, low=-2, high=10)
            Here, the mean in 0, the standard deviation is 3, the lower bound is -2,
            and the high is 10.

    NOTE: THIS IS A DIFFERENT PARAMETERIZATION THAN SCIPY
    &#39;&#39;&#39;
    @staticmethod
    def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        low: float=float(&#39;-inf&#39;), high: float=float(&#39;inf&#39;), size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `loc` and standard deviation `scale`

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        low, high : float
            Truncation points of normal distribution
        size : int
            Number of samples to return
        
        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        if size is not None:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        loc,scale,low,high) for i in range(len(size))])
                except:
                    value = scipy.stats.truncnorm(
                        a=(low-loc)/scale,
                        b=(high-loc)/scale,
                        loc=loc,
                        scale=scale).rvs(size=size)
            else:
                value = scipy.stats.truncnorm(
                    a=(low-loc)/scale,
                    b=(high-loc)/scale,
                    loc=loc,
                    scale=scale).rvs(size=size)
        else:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = C_SAMPLE.c_truncated_normal(loc, scale, low, high)
                except:
                    # likely because the loc and scale are vectors
                    # try vectorizing it
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        loc[i],scale[i],low,high) for i in range(len(loc))])
            else:
                value = scipy.stats.truncnorm(
                    a=(low-loc)/scale,
                    b=(high-loc)/scale,
                    loc=loc,
                    scale=scale).rvs(size=size)
        return value

    @staticmethod
    def pdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a truncated normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale
        low, high : float
            Truncation points of normal distribution

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.truncnorm.pdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)

    @staticmethod
    def logpdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a truncated normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale
        low, high : float
            Truncation points of normal distribution

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.truncnorm.logpdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)


class multivariate_normal(_BaseSample):
    &#39;&#39;&#39;Multivariate normal distribution - this is the same sampling methods as Numpy
    &#39;&#39;&#39;

    @staticmethod
    def sample(mean: np.ndarray, cov: np.ndarray, size: int=None) -&gt; np.ndarray:
        &#39;&#39;&#39;Sample from a multivariate normal random distribution.

        Parameters
        ----------
        mean : np.ndarray
            This is the mean
        cov : np.ndarray
            This is the covaraiance 
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        return npr.multivariate_normal(mean=mean, cov=cov, size=size)

    @staticmethod
    def logpdf(value: np.ndarray, mean: np.ndarray, cov: np.ndarray) -&gt; np.ndarray:
        &#39;&#39;&#39;Returns the probability density function of a multivariate normal distribution

        Parameters
        ----------
        value : np.ndarray
            This is the value we are calculating at
        mean : np.ndarray
            This is the mean
        cov : np.ndarray
            This is the scale

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        k = cov.shape[0]
        logdet = _log_det_func(cov)
        prec = np.linalg.pinv(cov)
        vmm = value - mean
        a = -k * 0.5 * _LOG_2PI
        b = -0.5 * logdet
        c = -0.5 * ( vmm.T @ prec @ vmm)
        return np.squeeze(a + b + c)


class gamma(_BaseSample):
    &#39;&#39;&#39;Gamma random distribution - this is the same parameterization as
    Numpy and scipy
    &#39;&#39;&#39;
    @staticmethod
    def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a gamma random distribution. This can be vectorized

        Parameters
        ----------
        shape : np.ndarray, float
            This is the shape parameter
        scale : np.ndarray, float
            This is the scale parameter
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return npr.gamma(shape=shape, scale=scale, size=size)

    @staticmethod
    def pdf(value: float, shape: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a gamma distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        shape : float
            This is the shape parameter
        scale : float
            This is the scale parameter

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)


class beta(_BaseSample):
    &#39;&#39;&#39;Beta random distribution - same parameterization as numpy
    &#39;&#39;&#39;
    @staticmethod
    def sample(a: Union[float, np.ndarray], b: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a beta random distribution. This can be vectorized

        Parameters
        ----------
        a, b : np.ndarray, float
            These are the a and b parmeters of the distribution

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return npr.beta(a=a, b=b, size=size)


class sics(_BaseSample):
    &#39;&#39;&#39;Scaled Inverse Chi^2 distribution.
    &#39;&#39;&#39;
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        dofdiv2 = dof/2
        a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
        b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
        return a*b
        
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        dofdiv2 = dof/2
        a = dofdiv2*LOG(scale*dofdiv2)
        b = -LGAMMA(dofdiv2)
        c = -scale * dofdiv2 / value
        d = -(1+dofdiv2) * LOG(value)
        return a + b + c + d

    @staticmethod
    def sample(dof: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)


class invchisquared(_BaseSample):

    @staticmethod
    def sample(nu: Union[float, np.ndarray], size: int=None) -&gt; Union[float, np.ndarray]:
        return invgamma.sample(shape=nu/2, scale=0.5, size=size)


class invgamma(_BaseSample):

    @staticmethod
    def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return 1/npr.gamma(shape=shape, scale=1/scale, size=size)

    @staticmethod
    def pdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)

    @staticmethod
    def logpdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)


class uniform(_BaseSample):
    @staticmethod
    def sample(low: Union[float, np.ndarray]=0, high: Union[float, np.ndarray]=1, 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return npr.uniform(low=low, high=high, size=size)

    @staticmethod
    def pdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low or value &gt; high:
            return 0
        else:
            return 1/(high-low)

    @staticmethod
    def logpdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low or value &gt; high:
            return 0
        else:
            return -LOG(high-low)

    @staticmethod
    def cdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low:
            return 0
        elif value &gt;= high:
            return 1
        else:
            return (value-low)/(high-value)

    @staticmethod
    def logcdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low:
            return float(&#39;-inf&#39;)
        elif value &gt;= high:
            return 0
        else:
            return LOG(value-low) - LOG(high-value)


class negative_binomial(_BaseSample):
    &#39;&#39;&#39;Parameterization of the negative binomial with mean $\\phi$ and dispersion
    $\\epsilon$:
        $\\text{NegBin}(y; \\phi, \\epsilon) =
            \\Gamma(r+y) / (y! * \\Gamma(r)) *
            (\\phi / (\\phi + r))^y *
            (r / (r + \\phi))^r$, where $r = 1/\\epsilon$
    We reparameterize the inputs so we can use the scipy implementation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean: float, dispersion: float, size: int=None) -&gt; float:
        &#39;&#39;&#39;Sample
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom(n=n, p=p).rvs(size=size)

    @staticmethod
    def pmf(value: float, mean: float, dispersion: float) -&gt; float:
        &#39;&#39;&#39;Calculate the pmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.pmf(value, n, p)

    @staticmethod
    def logpmf(value: float, mean: float, dispersion: float) -&gt; float:
        &#39;&#39;&#39;Calculate the logpmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.logpmf(value, n, p)

    @staticmethod
    @numba.jit(nopython=True, cache=True)
    def convert_params(mu: float, theta: float) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

        Parameters
        ----------
        mu : float
           Mean of NB distribution.
        theta : float
           Dispersion parameter used for variance calculation.

        Returns
        -------
        float, float
            Returns n, p

        See Also
        --------
        https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
        &#34;&#34;&#34;
        r = 1/theta
        var = mu + 1 / r * mu ** 2
        p = (var - mu) / var
        return r, 1-p


class bernoulli:

    @staticmethod
    def sample(p: float=0.5, size: int=None) -&gt; float:
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.random.israndom"><code class="name flex">
<span>def <span class="ident">israndom</span></span>(<span>x: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the input is a subclass of BaseRandom (not a
random variable (isRandomVariable))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Input instance to check the type of BaseRandom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is of type BaseRandom, else False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def israndom(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of BaseRandom (not a
    random variable (isRandomVariable))

    Parameters
    ----------
    x : any
        Input instance to check the type of BaseRandom

    Returns
    -------
    bool
        True if `x` is of type BaseRandom, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, _BaseSample)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>x: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets all of the seeds with the given seed <code>x</code></p>
<h2 id="parameters">Parameters</h2>
<p>x (int)
Seed to set everything at</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(x: int):
    &#39;&#39;&#39;Sets all of the seeds with the given seed `x`

    Parameters
    ----------
    x (int)
        Seed to set everything at
    &#39;&#39;&#39;
    np.random.seed(x)
    random.seed(x)
    if CUSTOM_DIST_AVAIL:
        C_SAMPLE.seed(x)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.random.bernoulli"><code class="flex name class">
<span>class <span class="ident">bernoulli</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class bernoulli:

    @staticmethod
    def sample(p: float=0.5, size: int=None) -&gt; float:
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.bernoulli.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>p: float = 0.5, size: int = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(p: float=0.5, size: int=None) -&gt; float:
    &#39;&#39;&#39;Sample a random variable from the distribution
    &#39;&#39;&#39;
    return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.beta"><code class="flex name class">
<span>class <span class="ident">beta</span></span>
</code></dt>
<dd>
<div class="desc"><p>Beta random distribution - same parameterization as numpy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class beta(_BaseSample):
    &#39;&#39;&#39;Beta random distribution - same parameterization as numpy
    &#39;&#39;&#39;
    @staticmethod
    def sample(a: Union[float, np.ndarray], b: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a beta random distribution. This can be vectorized

        Parameters
        ----------
        a, b : np.ndarray, float
            These are the a and b parmeters of the distribution

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return npr.beta(a=a, b=b, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.beta.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>a: Union[float, numpy.ndarray], b: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a beta random distribution. This can be vectorized</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong>, <strong><code>b</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>These are the a and b parmeters of the distribution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray, float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(a: Union[float, np.ndarray], b: Union[float, np.ndarray], 
    size: int=None) -&gt; Union[float, np.ndarray]:
    &#39;&#39;&#39;Sample from a beta random distribution. This can be vectorized

    Parameters
    ----------
    a, b : np.ndarray, float
        These are the a and b parmeters of the distribution

    Returns
    -------
    np.ndarray, float
    &#39;&#39;&#39;
    return npr.beta(a=a, b=b, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.gamma"><code class="flex name class">
<span>class <span class="ident">gamma</span></span>
</code></dt>
<dd>
<div class="desc"><p>Gamma random distribution - this is the same parameterization as
Numpy and scipy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class gamma(_BaseSample):
    &#39;&#39;&#39;Gamma random distribution - this is the same parameterization as
    Numpy and scipy
    &#39;&#39;&#39;
    @staticmethod
    def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a gamma random distribution. This can be vectorized

        Parameters
        ----------
        shape : np.ndarray, float
            This is the shape parameter
        scale : np.ndarray, float
            This is the scale parameter
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return npr.gamma(shape=shape, scale=scale, size=size)

    @staticmethod
    def pdf(value: float, shape: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a gamma distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        shape : float
            This is the shape parameter
        scale : float
            This is the scale parameter

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.gamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: float, shape: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the probability density function of a gamma distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the shape parameter</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale parameter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value: float, shape: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the probability density function of a gamma distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    shape : float
        This is the shape parameter
    scale : float
        This is the scale parameter

    Returns
    -------
    float
    &#39;&#39;&#39;
    return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.gamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>shape: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a gamma random distribution. This can be vectorized</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the shape parameter</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the scale parameter</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray, float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
    size: int=None) -&gt; Union[float, np.ndarray]:
    &#39;&#39;&#39;Sample from a gamma random distribution. This can be vectorized

    Parameters
    ----------
    shape : np.ndarray, float
        This is the shape parameter
    scale : np.ndarray, float
        This is the scale parameter
    size : int
        Number of samples to return

    Returns
    -------
    np.ndarray, float
    &#39;&#39;&#39;
    return npr.gamma(shape=shape, scale=scale, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.invchisquared"><code class="flex name class">
<span>class <span class="ident">invchisquared</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class invchisquared(_BaseSample):

    @staticmethod
    def sample(nu: Union[float, np.ndarray], size: int=None) -&gt; Union[float, np.ndarray]:
        return invgamma.sample(shape=nu/2, scale=0.5, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.invchisquared.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>nu: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(nu: Union[float, np.ndarray], size: int=None) -&gt; Union[float, np.ndarray]:
    return invgamma.sample(shape=nu/2, scale=0.5, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.invgamma"><code class="flex name class">
<span>class <span class="ident">invgamma</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class invgamma(_BaseSample):

    @staticmethod
    def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return 1/npr.gamma(shape=shape, scale=1/scale, size=size)

    @staticmethod
    def pdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)

    @staticmethod
    def logpdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.invgamma.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: Union[float, numpy.ndarray], shape: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
    scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.invgamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: Union[float, numpy.ndarray], shape: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value: Union[float, np.ndarray], shape: Union[float, np.ndarray], 
    scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.invgamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>shape: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(shape: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
    size: int=None) -&gt; Union[float, np.ndarray]:
    return 1/npr.gamma(shape=shape, scale=1/scale, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.lognormal"><code class="flex name class">
<span>class <span class="ident">lognormal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Log-normal distribution:
X = exp(\mu + \sigma Z), Z ~ Normal(0,1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lognormal(_BaseSample):
    &#39;&#39;&#39;Log-normal distribution:
    X = exp(\mu + \sigma Z), Z ~ Normal(0,1)
    &#39;&#39;&#39; 
    @staticmethod
    def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a log-normal random distribution. This can be vectorized

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        return np.exp(loc + scale * npr.normal(0,1,size=size))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a log-normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _INV_SQRT_2PI * (1/(scale*value)) * EXP(-0.5 * \
            ((LOG(value)-loc)/scale) ** 2)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a log-normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_INV_SQRT_2PI - LOG(scale) - LOG(value) + \
            (-0.5*((LOG(value)-loc)/scale)**2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.lognormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the log probability density function of a log-normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the log probability density function of a log-normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return _LOG_INV_SQRT_2PI - LOG(scale) - LOG(value) + \
        (-0.5*((LOG(value)-loc)/scale)**2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.lognormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the probability density function of a log-normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the probability density function of a log-normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return _INV_SQRT_2PI * (1/(scale*value)) * EXP(-0.5 * \
        ((LOG(value)-loc)/scale) ** 2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.lognormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>loc: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a log-normal random distribution. This can be vectorized</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the scale</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray, float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
    size: int=None) -&gt; Union[float, np.ndarray]:
    &#39;&#39;&#39;Sample from a log-normal random distribution. This can be vectorized

    Parameters
    ----------
    loc : np.ndarray, float
        This is the mean
    scale : np.ndarray, float
        This is the scale
    size : int
        Number of samples to return

    Returns
    -------
    np.ndarray, float
    &#39;&#39;&#39;
    return np.exp(loc + scale * npr.normal(0,1,size=size))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.misc"><code class="flex name class">
<span>class <span class="ident">misc</span></span>
</code></dt>
<dd>
<div class="desc"><p>These are miscellaneus methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class misc:
    &#39;&#39;&#39;These are miscellaneus methods
    &#39;&#39;&#39;
    @staticmethod
    def multivariate_normal_fast_2d(mean: Union[np.ndarray, List], 
        cov: np.ndarray) -&gt; Union[np.ndarray, List]:
        &#39;&#39;&#39;Sample from 2d normal.

        Parameters
        ----------
        mean : 1d array
        cov : 2 x 2 array

        Returns
        -------
        np.ndarray (2,)
            Two samples
        &#39;&#39;&#39;
        z0 = C_SAMPLE.c_standard_normal()
        SQRT_COV_00 = math.sqrt(cov[0,0])
        mean[0] += SQRT_COV_00 * z0
        mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
            cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
        return mean

    @staticmethod
    def fast_sample_standard_uniform() -&gt; float:
        &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
        &#39;&#39;&#39;
        return C_SAMPLE.c_standard_uniform()

    @staticmethod
    def fast_sample_normal(loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
        Only accepts floats

        Parameters
        ----------
        loc, scale : float
            Mean and standard devition, respectively

        Returns
        -------
        float
        &#39;&#39;&#39;
        return C_SAMPLE.c_normal(loc, scale)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.misc.fast_sample_normal"><code class="name flex">
<span>def <span class="ident">fast_sample_normal</span></span>(<span>loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a c_implementation of a normal distribution.
Only accepts floats</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong>, <strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean and standard devition, respectively</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fast_sample_normal(loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
    Only accepts floats

    Parameters
    ----------
    loc, scale : float
        Mean and standard devition, respectively

    Returns
    -------
    float
    &#39;&#39;&#39;
    return C_SAMPLE.c_normal(loc, scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.misc.fast_sample_standard_uniform"><code class="name flex">
<span>def <span class="ident">fast_sample_standard_uniform</span></span>(<span>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a uniform distribution on [0,1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fast_sample_standard_uniform() -&gt; float:
    &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
    &#39;&#39;&#39;
    return C_SAMPLE.c_standard_uniform()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.misc.multivariate_normal_fast_2d"><code class="name flex">
<span>def <span class="ident">multivariate_normal_fast_2d</span></span>(<span>mean: Union[numpy.ndarray, List], cov: numpy.ndarray) ‑> Union[numpy.ndarray, List]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from 2d normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>1d array</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>2 x 2 array</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray (2,)</code></dt>
<dd>Two samples</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multivariate_normal_fast_2d(mean: Union[np.ndarray, List], 
    cov: np.ndarray) -&gt; Union[np.ndarray, List]:
    &#39;&#39;&#39;Sample from 2d normal.

    Parameters
    ----------
    mean : 1d array
    cov : 2 x 2 array

    Returns
    -------
    np.ndarray (2,)
        Two samples
    &#39;&#39;&#39;
    z0 = C_SAMPLE.c_standard_normal()
    SQRT_COV_00 = math.sqrt(cov[0,0])
    mean[0] += SQRT_COV_00 * z0
    mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
        cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
    return mean</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.multivariate_normal"><code class="flex name class">
<span>class <span class="ident">multivariate_normal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Multivariate normal distribution - this is the same sampling methods as Numpy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class multivariate_normal(_BaseSample):
    &#39;&#39;&#39;Multivariate normal distribution - this is the same sampling methods as Numpy
    &#39;&#39;&#39;

    @staticmethod
    def sample(mean: np.ndarray, cov: np.ndarray, size: int=None) -&gt; np.ndarray:
        &#39;&#39;&#39;Sample from a multivariate normal random distribution.

        Parameters
        ----------
        mean : np.ndarray
            This is the mean
        cov : np.ndarray
            This is the covaraiance 
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        return npr.multivariate_normal(mean=mean, cov=cov, size=size)

    @staticmethod
    def logpdf(value: np.ndarray, mean: np.ndarray, cov: np.ndarray) -&gt; np.ndarray:
        &#39;&#39;&#39;Returns the probability density function of a multivariate normal distribution

        Parameters
        ----------
        value : np.ndarray
            This is the value we are calculating at
        mean : np.ndarray
            This is the mean
        cov : np.ndarray
            This is the scale

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        k = cov.shape[0]
        logdet = _log_det_func(cov)
        prec = np.linalg.pinv(cov)
        vmm = value - mean
        a = -k * 0.5 * _LOG_2PI
        b = -0.5 * logdet
        c = -0.5 * ( vmm.T @ prec @ vmm)
        return np.squeeze(a + b + c)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.multivariate_normal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: numpy.ndarray, mean: numpy.ndarray, cov: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the probability density function of a multivariate normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value: np.ndarray, mean: np.ndarray, cov: np.ndarray) -&gt; np.ndarray:
    &#39;&#39;&#39;Returns the probability density function of a multivariate normal distribution

    Parameters
    ----------
    value : np.ndarray
        This is the value we are calculating at
    mean : np.ndarray
        This is the mean
    cov : np.ndarray
        This is the scale

    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    k = cov.shape[0]
    logdet = _log_det_func(cov)
    prec = np.linalg.pinv(cov)
    vmm = value - mean
    a = -k * 0.5 * _LOG_2PI
    b = -0.5 * logdet
    c = -0.5 * ( vmm.T @ prec @ vmm)
    return np.squeeze(a + b + c)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.multivariate_normal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean: numpy.ndarray, cov: numpy.ndarray, size: int = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a multivariate normal random distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>This is the covaraiance</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean: np.ndarray, cov: np.ndarray, size: int=None) -&gt; np.ndarray:
    &#39;&#39;&#39;Sample from a multivariate normal random distribution.

    Parameters
    ----------
    mean : np.ndarray
        This is the mean
    cov : np.ndarray
        This is the covaraiance 
    size : int
        Number of samples to return

    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    return npr.multivariate_normal(mean=mean, cov=cov, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial"><code class="flex name class">
<span>class <span class="ident">negative_binomial</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parameterization of the negative binomial with mean $\phi$ and dispersion
$\epsilon$:
$\text{NegBin}(y; \phi, \epsilon) =
\Gamma(r+y) / (y! * \Gamma(r)) *
(\phi / (\phi + r))^y *
(r / (r + \phi))^r$, where $r = 1/\epsilon$
We reparameterize the inputs so we can use the scipy implementation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class negative_binomial(_BaseSample):
    &#39;&#39;&#39;Parameterization of the negative binomial with mean $\\phi$ and dispersion
    $\\epsilon$:
        $\\text{NegBin}(y; \\phi, \\epsilon) =
            \\Gamma(r+y) / (y! * \\Gamma(r)) *
            (\\phi / (\\phi + r))^y *
            (r / (r + \\phi))^r$, where $r = 1/\\epsilon$
    We reparameterize the inputs so we can use the scipy implementation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean: float, dispersion: float, size: int=None) -&gt; float:
        &#39;&#39;&#39;Sample
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom(n=n, p=p).rvs(size=size)

    @staticmethod
    def pmf(value: float, mean: float, dispersion: float) -&gt; float:
        &#39;&#39;&#39;Calculate the pmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.pmf(value, n, p)

    @staticmethod
    def logpmf(value: float, mean: float, dispersion: float) -&gt; float:
        &#39;&#39;&#39;Calculate the logpmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.logpmf(value, n, p)

    @staticmethod
    @numba.jit(nopython=True, cache=True)
    def convert_params(mu: float, theta: float) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

        Parameters
        ----------
        mu : float
           Mean of NB distribution.
        theta : float
           Dispersion parameter used for variance calculation.

        Returns
        -------
        float, float
            Returns n, p

        See Also
        --------
        https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
        &#34;&#34;&#34;
        r = 1/theta
        var = mu + 1 / r * mu ** 2
        p = (var - mu) / var
        return r, 1-p</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.negative_binomial.convert_params"><code class="name flex">
<span>def <span class="ident">convert_params</span></span>(<span>mu: float, theta: float) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Mean of NB distribution.</dt>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Dispersion parameter used for variance calculation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float, float</code></dt>
<dd>Returns n, p</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>&lt;https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations&gt;</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, cache=True)
def convert_params(mu: float, theta: float) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

    Parameters
    ----------
    mu : float
       Mean of NB distribution.
    theta : float
       Dispersion parameter used for variance calculation.

    Returns
    -------
    float, float
        Returns n, p

    See Also
    --------
    https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
    &#34;&#34;&#34;
    r = 1/theta
    var = mu + 1 / r * mu ** 2
    p = (var - mu) / var
    return r, 1-p</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.logpmf"><code class="name flex">
<span>def <span class="ident">logpmf</span></span>(<span>value: float, mean: float, dispersion: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpmf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpmf(value: float, mean: float, dispersion: float) -&gt; float:
    &#39;&#39;&#39;Calculate the logpmf
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom.logpmf(value, n, p)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.pmf"><code class="name flex">
<span>def <span class="ident">pmf</span></span>(<span>value: float, mean: float, dispersion: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pmf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pmf(value: float, mean: float, dispersion: float) -&gt; float:
    &#39;&#39;&#39;Calculate the pmf
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom.pmf(value, n, p)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean: float, dispersion: float, size: int = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Sample</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean: float, dispersion: float, size: int=None) -&gt; float:
    &#39;&#39;&#39;Sample
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom(n=n, p=p).rvs(size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.normal"><code class="flex name class">
<span>class <span class="ident">normal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Normal distribution parameterized by a mean and standard deviation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class normal(_BaseSample):
    &#39;&#39;&#39;Normal distribution parameterized by a mean and standard deviation
    &#39;&#39;&#39;
    @staticmethod
    def sample(loc: Union[float, np.ndarray]=0, scale: Union[float, np.ndarray]=1,
        size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a normal random distribution. This can be vectorized

        NOTE: If you want to sample a single scalar value with a normal distribution,
        use the function `mdsine2.random.misc.fast_sample_normal`

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        size : int
            Number of samples to return

        Returns
        -------
        np.ndarray, float

        See Also
        --------
        mdsine2.random.misc.fast_sample_normal
        &#39;&#39;&#39;
        return npr.normal(loc, scale, size=size)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _INV_SQRT_2PI * EXP(-0.5*((value-loc)/scale)**2) / scale

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_INV_SQRT_2PI + (-0.5*((value-loc)/scale)**2) - LOG(scale)


    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def cdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the cumulative density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logcdf(value: float, loc: float, scale: float) -&gt; float:
        &#39;&#39;&#39;Returns the log cumulative density function of a normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale

        Returns
        -------
        float
        &#39;&#39;&#39;
        return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.normal.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cumulative density function of a normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def cdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the cumulative density function of a normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the log cumulative density function of a normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def logcdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the log cumulative density function of a normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-loc)/scale)))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the log probability density function of a normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the log probability density function of a normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return _LOG_INV_SQRT_2PI + (-0.5*((value-loc)/scale)**2) - LOG(scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: float, loc: float, scale: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the probability density function of a normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value: float, loc: float, scale: float) -&gt; float:
    &#39;&#39;&#39;Returns the probability density function of a normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale

    Returns
    -------
    float
    &#39;&#39;&#39;
    return _INV_SQRT_2PI * EXP(-0.5*((value-loc)/scale)**2) / scale</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>loc: Union[float, numpy.ndarray] = 0, scale: Union[float, numpy.ndarray] = 1, size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a normal random distribution. This can be vectorized</p>
<p>NOTE: If you want to sample a single scalar value with a normal distribution,
use the function <code>mdsine2.random.misc.fast_sample_normal</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the scale</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray, float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>mdsine2.random.misc.fast_sample_normal</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(loc: Union[float, np.ndarray]=0, scale: Union[float, np.ndarray]=1,
    size: int=None) -&gt; Union[float, np.ndarray]:
    &#39;&#39;&#39;Sample from a normal random distribution. This can be vectorized

    NOTE: If you want to sample a single scalar value with a normal distribution,
    use the function `mdsine2.random.misc.fast_sample_normal`

    Parameters
    ----------
    loc : np.ndarray, float
        This is the mean
    scale : np.ndarray, float
        This is the scale
    size : int
        Number of samples to return

    Returns
    -------
    np.ndarray, float

    See Also
    --------
    mdsine2.random.misc.fast_sample_normal
    &#39;&#39;&#39;
    return npr.normal(loc, scale, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.sics"><code class="flex name class">
<span>class <span class="ident">sics</span></span>
</code></dt>
<dd>
<div class="desc"><p>Scaled Inverse Chi^2 distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sics(_BaseSample):
    &#39;&#39;&#39;Scaled Inverse Chi^2 distribution.
    &#39;&#39;&#39;
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        dofdiv2 = dof/2
        a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
        b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
        return a*b
        
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
        scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        dofdiv2 = dof/2
        a = dofdiv2*LOG(scale*dofdiv2)
        b = -LGAMMA(dofdiv2)
        c = -scale * dofdiv2 / value
        d = -(1+dofdiv2) * LOG(value)
        return a + b + c + d

    @staticmethod
    def sample(dof: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.sics.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: Union[float, numpy.ndarray], dof: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
    scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    dofdiv2 = dof/2
    a = dofdiv2*LOG(scale*dofdiv2)
    b = -LGAMMA(dofdiv2)
    c = -scale * dofdiv2 / value
    d = -(1+dofdiv2) * LOG(value)
    return a + b + c + d</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.sics.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: Union[float, numpy.ndarray], dof: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value: Union[float, np.ndarray], dof: Union[float, np.ndarray], 
    scale: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    dofdiv2 = dof/2
    a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
    b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
    return a*b</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.sics.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>dof: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray], size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(dof: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
    size: int=None) -&gt; Union[float, np.ndarray]:
    return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.truncnormal"><code class="flex name class">
<span>class <span class="ident">truncnormal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Truncated normal distribution.</p>
<p>We parameterize the truncated normal distribution with the mean <code>loc</code> and
standard deviation <code>scale</code> of the underlying normal distirbution and then we
specified the truncation bounds:
</p>
<p>For example:
mdsine2.random.truncnormal.sample(0, 3, low=-2, high=10)
Here, the mean in 0, the standard deviation is 3, the lower bound is -2,
and the high is 10.</p>
<p>NOTE: THIS IS A DIFFERENT PARAMETERIZATION THAN SCIPY</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class truncnormal(_BaseSample):
    &#39;&#39;&#39;Truncated normal distribution.

    We parameterize the truncated normal distribution with the mean `loc` and 
    standard deviation `scale` of the underlying normal distirbution and then we
    specified the truncation bounds:    
    
    For example:
        mdsine2.random.truncnormal.sample(0, 3, low=-2, high=10)
            Here, the mean in 0, the standard deviation is 3, the lower bound is -2,
            and the high is 10.

    NOTE: THIS IS A DIFFERENT PARAMETERIZATION THAN SCIPY
    &#39;&#39;&#39;
    @staticmethod
    def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
        low: float=float(&#39;-inf&#39;), high: float=float(&#39;inf&#39;), size: int=None) -&gt; Union[float, np.ndarray]:
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `loc` and standard deviation `scale`

        Parameters
        ----------
        loc : np.ndarray, float
            This is the mean
        scale : np.ndarray, float
            This is the scale
        low, high : float
            Truncation points of normal distribution
        size : int
            Number of samples to return
        
        Returns
        -------
        np.ndarray, float
        &#39;&#39;&#39;
        if size is not None:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        loc,scale,low,high) for i in range(len(size))])
                except:
                    value = scipy.stats.truncnorm(
                        a=(low-loc)/scale,
                        b=(high-loc)/scale,
                        loc=loc,
                        scale=scale).rvs(size=size)
            else:
                value = scipy.stats.truncnorm(
                    a=(low-loc)/scale,
                    b=(high-loc)/scale,
                    loc=loc,
                    scale=scale).rvs(size=size)
        else:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = C_SAMPLE.c_truncated_normal(loc, scale, low, high)
                except:
                    # likely because the loc and scale are vectors
                    # try vectorizing it
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        loc[i],scale[i],low,high) for i in range(len(loc))])
            else:
                value = scipy.stats.truncnorm(
                    a=(low-loc)/scale,
                    b=(high-loc)/scale,
                    loc=loc,
                    scale=scale).rvs(size=size)
        return value

    @staticmethod
    def pdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
        &#39;&#39;&#39;Returns the probability density function of a truncated normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale
        low, high : float
            Truncation points of normal distribution

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.truncnorm.pdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)

    @staticmethod
    def logpdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
        &#39;&#39;&#39;Returns the log probability density function of a truncated normal distribution

        Parameters
        ----------
        value : float
            This is the value we are calculating at
        loc : float
            This is the mean
        scale : float
            This is the scale
        low, high : float
            Truncation points of normal distribution

        Returns
        -------
        float
        &#39;&#39;&#39;
        return scipy.stats.truncnorm.logpdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.truncnormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: float, loc: float, scale: float, low: float, high: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the log probability density function of a truncated normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
<dt><strong><code>low</code></strong>, <strong><code>high</code></strong> :&ensp;<code>float</code></dt>
<dd>Truncation points of normal distribution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
    &#39;&#39;&#39;Returns the log probability density function of a truncated normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale
    low, high : float
        Truncation points of normal distribution

    Returns
    -------
    float
    &#39;&#39;&#39;
    return scipy.stats.truncnorm.logpdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.truncnormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: float, loc: float, scale: float, low: float, high: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the probability density function of a truncated normal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the value we are calculating at</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>This is the scale</dd>
<dt><strong><code>low</code></strong>, <strong><code>high</code></strong> :&ensp;<code>float</code></dt>
<dd>Truncation points of normal distribution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value: float, loc: float, scale: float, low: float, high: float) -&gt; float:
    &#39;&#39;&#39;Returns the probability density function of a truncated normal distribution

    Parameters
    ----------
    value : float
        This is the value we are calculating at
    loc : float
        This is the mean
    scale : float
        This is the scale
    low, high : float
        Truncation points of normal distribution

    Returns
    -------
    float
    &#39;&#39;&#39;
    return scipy.stats.truncnorm.pdf(value, (low-loc)/scale, (high-loc)/scale, loc, scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.truncnormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>loc: Union[float, numpy.ndarray], scale: Union[float, numpy.ndarray], low: float = -inf, high: float = inf, size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a truncated normal random distribution defined on
[low, high] with mean <code>loc</code> and standard deviation <code>scale</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the mean</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>np.ndarray, float</code></dt>
<dd>This is the scale</dd>
<dt><strong><code>low</code></strong>, <strong><code>high</code></strong> :&ensp;<code>float</code></dt>
<dd>Truncation points of normal distribution</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray, float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(loc: Union[float, np.ndarray], scale: Union[float, np.ndarray], 
    low: float=float(&#39;-inf&#39;), high: float=float(&#39;inf&#39;), size: int=None) -&gt; Union[float, np.ndarray]:
    &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
    [low, high] with mean `loc` and standard deviation `scale`

    Parameters
    ----------
    loc : np.ndarray, float
        This is the mean
    scale : np.ndarray, float
        This is the scale
    low, high : float
        Truncation points of normal distribution
    size : int
        Number of samples to return
    
    Returns
    -------
    np.ndarray, float
    &#39;&#39;&#39;
    if size is not None:
        if CUSTOM_DIST_AVAIL:
            try:
                value = np.asarray([C_SAMPLE.c_truncated_normal(
                    loc,scale,low,high) for i in range(len(size))])
            except:
                value = scipy.stats.truncnorm(
                    a=(low-loc)/scale,
                    b=(high-loc)/scale,
                    loc=loc,
                    scale=scale).rvs(size=size)
        else:
            value = scipy.stats.truncnorm(
                a=(low-loc)/scale,
                b=(high-loc)/scale,
                loc=loc,
                scale=scale).rvs(size=size)
    else:
        if CUSTOM_DIST_AVAIL:
            try:
                value = C_SAMPLE.c_truncated_normal(loc, scale, low, high)
            except:
                # likely because the loc and scale are vectors
                # try vectorizing it
                value = np.asarray([C_SAMPLE.c_truncated_normal(
                    loc[i],scale[i],low,high) for i in range(len(loc))])
        else:
            value = scipy.stats.truncnorm(
                a=(low-loc)/scale,
                b=(high-loc)/scale,
                loc=loc,
                scale=scale).rvs(size=size)
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.uniform"><code class="flex name class">
<span>class <span class="ident">uniform</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class uniform(_BaseSample):
    @staticmethod
    def sample(low: Union[float, np.ndarray]=0, high: Union[float, np.ndarray]=1, 
        size: int=None) -&gt; Union[float, np.ndarray]:
        return npr.uniform(low=low, high=high, size=size)

    @staticmethod
    def pdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low or value &gt; high:
            return 0
        else:
            return 1/(high-low)

    @staticmethod
    def logpdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low or value &gt; high:
            return 0
        else:
            return -LOG(high-low)

    @staticmethod
    def cdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low:
            return 0
        elif value &gt;= high:
            return 1
        else:
            return (value-low)/(high-value)

    @staticmethod
    def logcdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
        high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
        if value &lt; low:
            return float(&#39;-inf&#39;)
        elif value &gt;= high:
            return 0
        else:
            return LOG(value-low) - LOG(high-value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.uniform.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>value: Union[float, numpy.ndarray], low: Union[float, numpy.ndarray], high: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def cdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
    high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    if value &lt; low:
        return 0
    elif value &gt;= high:
        return 1
    else:
        return (value-low)/(high-value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>value: Union[float, numpy.ndarray], low: Union[float, numpy.ndarray], high: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logcdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
    high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    if value &lt; low:
        return float(&#39;-inf&#39;)
    elif value &gt;= high:
        return 0
    else:
        return LOG(value-low) - LOG(high-value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value: Union[float, numpy.ndarray], low: Union[float, numpy.ndarray], high: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
    high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    if value &lt; low or value &gt; high:
        return 0
    else:
        return -LOG(high-low)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value: Union[float, numpy.ndarray], low: Union[float, numpy.ndarray], high: Union[float, numpy.ndarray]) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value: Union[float, np.ndarray], low: Union[float, np.ndarray], 
    high: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:
    if value &lt; low or value &gt; high:
        return 0
    else:
        return 1/(high-low)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>low: Union[float, numpy.ndarray] = 0, high: Union[float, numpy.ndarray] = 1, size: int = None) ‑> Union[float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(low: Union[float, np.ndarray]=0, high: Union[float, np.ndarray]=1, 
    size: int=None) -&gt; Union[float, np.ndarray]:
    return npr.uniform(low=low, high=high, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.random.israndom" href="#mdsine2.pylab.random.israndom">israndom</a></code></li>
<li><code><a title="mdsine2.pylab.random.seed" href="#mdsine2.pylab.random.seed">seed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.random.bernoulli" href="#mdsine2.pylab.random.bernoulli">bernoulli</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.bernoulli.sample" href="#mdsine2.pylab.random.bernoulli.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.beta" href="#mdsine2.pylab.random.beta">beta</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.beta.sample" href="#mdsine2.pylab.random.beta.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.gamma" href="#mdsine2.pylab.random.gamma">gamma</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.gamma.pdf" href="#mdsine2.pylab.random.gamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.gamma.sample" href="#mdsine2.pylab.random.gamma.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.invchisquared" href="#mdsine2.pylab.random.invchisquared">invchisquared</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.invchisquared.sample" href="#mdsine2.pylab.random.invchisquared.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.invgamma" href="#mdsine2.pylab.random.invgamma">invgamma</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.invgamma.logpdf" href="#mdsine2.pylab.random.invgamma.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.invgamma.pdf" href="#mdsine2.pylab.random.invgamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.invgamma.sample" href="#mdsine2.pylab.random.invgamma.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.lognormal" href="#mdsine2.pylab.random.lognormal">lognormal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.lognormal.logpdf" href="#mdsine2.pylab.random.lognormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.lognormal.pdf" href="#mdsine2.pylab.random.lognormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.lognormal.sample" href="#mdsine2.pylab.random.lognormal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.misc" href="#mdsine2.pylab.random.misc">misc</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.misc.fast_sample_normal" href="#mdsine2.pylab.random.misc.fast_sample_normal">fast_sample_normal</a></code></li>
<li><code><a title="mdsine2.pylab.random.misc.fast_sample_standard_uniform" href="#mdsine2.pylab.random.misc.fast_sample_standard_uniform">fast_sample_standard_uniform</a></code></li>
<li><code><a title="mdsine2.pylab.random.misc.multivariate_normal_fast_2d" href="#mdsine2.pylab.random.misc.multivariate_normal_fast_2d">multivariate_normal_fast_2d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.multivariate_normal" href="#mdsine2.pylab.random.multivariate_normal">multivariate_normal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.multivariate_normal.logpdf" href="#mdsine2.pylab.random.multivariate_normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.multivariate_normal.sample" href="#mdsine2.pylab.random.multivariate_normal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.negative_binomial" href="#mdsine2.pylab.random.negative_binomial">negative_binomial</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.negative_binomial.convert_params" href="#mdsine2.pylab.random.negative_binomial.convert_params">convert_params</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.logpmf" href="#mdsine2.pylab.random.negative_binomial.logpmf">logpmf</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.pmf" href="#mdsine2.pylab.random.negative_binomial.pmf">pmf</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.sample" href="#mdsine2.pylab.random.negative_binomial.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.normal" href="#mdsine2.pylab.random.normal">normal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.normal.cdf" href="#mdsine2.pylab.random.normal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.logcdf" href="#mdsine2.pylab.random.normal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.logpdf" href="#mdsine2.pylab.random.normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.pdf" href="#mdsine2.pylab.random.normal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.sample" href="#mdsine2.pylab.random.normal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.sics" href="#mdsine2.pylab.random.sics">sics</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.sics.logpdf" href="#mdsine2.pylab.random.sics.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.sics.pdf" href="#mdsine2.pylab.random.sics.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.sics.sample" href="#mdsine2.pylab.random.sics.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.truncnormal" href="#mdsine2.pylab.random.truncnormal">truncnormal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.truncnormal.logpdf" href="#mdsine2.pylab.random.truncnormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.truncnormal.pdf" href="#mdsine2.pylab.random.truncnormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.truncnormal.sample" href="#mdsine2.pylab.random.truncnormal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.uniform" href="#mdsine2.pylab.random.uniform">uniform</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.uniform.cdf" href="#mdsine2.pylab.random.uniform.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.logcdf" href="#mdsine2.pylab.random.uniform.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.logpdf" href="#mdsine2.pylab.random.uniform.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.pdf" href="#mdsine2.pylab.random.uniform.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.sample" href="#mdsine2.pylab.random.uniform.sample">sample</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>